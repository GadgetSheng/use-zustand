[精读《zustand 源码》](https://zhuanlan.zhihu.com/p/461152248)

## 监听指定变量
`subscribeWithSelector` 这个中间件可以让我们把 selector 用在subscribe 函数上，相比于redux传统的 subscribe 就可以有针对性的监听了:
```js
import { subscribeWithSelector } from 'zustand/middleware'

const useStore=create(subscribeWithSelector(()=>({
    paw: true,
    snout: true,
    fur: true
})))

const unSub2= useStore.subscribe(s=>s.paw,console.log)

const unSub3= useStore.subscribe(s=>s.paw,(paw,previous)=>console.log(paw,previous))

const unSub4= useStore.subscribe(s=>[s.paw,s.fur],console.log,{equalityFn: shallow})

const unSub5= useStore.subscribe(s=>s.paw,console.log,{ fireImmediately: true})
```

# 精读源码
其实大部分使用特性都是在利用`React`语法
50%的特性属于`React`通用特性

## 创建store实例
### `vanilla.ts` > createStore
返回一个类似 redux store 的数据管理实例
拥有四个非常常见的API
```ts
export interface StoreApi<T> {
  setState: SetStateInternal<T>
  getState: () => T
  subscribe: (
    listener: (state: T, prevState: T) => void
  ) => () => void
  /** @deprecated Use `unsubscribe` returned by `subscribe` */
  destroy: () => void
}
```

### getState
```ts
export type GetState<T extends State> = () => T
```

### setState
做了两件事，修改state 执行 listener
```ts
type SetStateInternal<T> = {
  _(
    partial: T | Partial<T> | { _(state: T): T | Partial<T> }['_'],
    replace?: boolean | undefined
  ): void
}['_']
```

```ts
const setState: StoreApi<TState>['setState'] = (partial, replace) => {
  const nextState = typeof partial === 'function'
      ? (partial as (state: TState) => TState)(state)
      : partial
  if (!Object.is(nextState, state)) {
    const previousState = state
    state =
      replace ?? typeof nextState !== 'object'
        ? (nextState as TState)
        : Object.assign({}, state, nextState)
    listeners.forEach((listener) => listener(state, previousState))
  }
}
```
唯一重要的是 `listener(state,prev)`
> `listeners` 就是一个 Set 对象

```ts
type TState = ReturnType<typeof createState>
type Listener = (state: TState, prevState: TState) => void

const listeners: Set<Listener> = new Set()
```
注册和销毁时机
1. subscribe 注册的监听函数会作为 listener 添加到Set中=>当发生setState时被调用
2. destroy 函数调用时 销毁

看 createStore的定义与结尾
```ts
function createStore(createState) {
  let state: TState
  // const setState = ...
  // const getState = ...
  /** ... */
  const api = { setState, getState, subscribe, destroy }
  state = createState(setState, getState, api)
  return api as any
}
```
> state 虽然是个简单对象
我们可以在`create` 创建 store 
利用callback(set,get,api)对state赋值

```js
import { create } from 'zustand'
create((set,get,api)=>({
    // xxxx
}))
```

## create函数实现
create 定义在 react.ts文件中 
并调用了 createStore 创建框架无关数据流

因为返回的useStore是一个Hooks所以本身具有React环境特性
调用createStore创建基础store，因为对框架来说是内部API 所以命名**api**

```ts
const api =
  typeof createState === 'function' ? createStore(createState) : createState

// >简化版
const useStore:any =<StateSlice>(
  selector: StateSelector<TState,StateSlice> = api.getState as any,
  equalityFn: EqualityChecker<StateSlice> = Object.is
) => {} /** ... */
```
简单来说 useStore后面部分是
1. 利用subscribe监听变化，
2. 并在需要的时候强制刷新当前组件，
3. 并传入最新的state给到useStore

所以第一步当然是创建 **forceUpdate** 函数

```ts
const [,forceUpdate] =useReducer((c)=>c+1,0) as [never,()=>void]
```
调用API拿到state并传给selector
并调用equalityFn 判断状态是否发生了变化

```ts
// >简化版 checkIfSnapshotChanged
// prev=inst.value
// latest=inst.getSnapshot();
const state=api.getState()
const newStateSlice=selector(state)
hasNewStateSlice=!equalityFn(
    currentSliceRef.current as StateSlice,
    newStateSlice
)
return newStateSlice
```
如果状态变化了 就更新currentSliceRef.current
> in `use-sync-external-store/src/useSyncExternalStoreWithSelector.js`

// React.useSyncExternalStore  可以让你subscribe外部store
// https://beta.reactjs.org/reference/react/useSyncExternalStore#usesyncexternalstore
```ts
useIsomorphicLayoutEffect(()=>{
  // =forceUpdate
  if(hasNewStateSlice){
    currentSliceRef.current = newStateSlice as StateSlice
  }
  stateRef.current=state
  selectorRef.current = selector
  equalityFnRef.current= equalityFn
  erroredRef.current =false
})
```
> `useIsomorphicLayoutEffect` 是同构框架常用API套路，
>
> 在前端环境是 `useLayoutEffect`,在node环境是`useEffect`

useStore 最后返回值:
```ts
// Read the current snapshot from the store on every render. Again, this
// breaks the rules of React, and only works here because of specific
// implementation details, most importantly that updates are
// always synchronous.
// const value = getSnapshot();
const sliceToReturn = hasNewStateSlice
? (newStateSlice as StateSlice)
: currentSliceRef.current
useDebugValue(sliceToReturn)
return sliceToReturn
```

逻辑=== 如果state变化了，则返回新的state，否则返回旧的，这样可以保证compare函数判断相等，
> `返回对象的引用完全相同` 这个是 **不可变数据的核心实现**。

如何在selector变化时更新store呢
> +++ 核心代码 +++
调用了subscribe
```ts
useIsomorphicLayoutEffect(()=>{
  const listener = ()=>{
    try{
      const nextState=api.getState()
      const nextStateSlice=selectorRef.current(nextState)
      if(!equalityFnRef.current(currentSliceRef.current as StateSlice,
      nextStateSlice)){
        stateRef.current=nextState
        currentSliceRef.current =nextStateSlice
        forceUpdate()
      }
    }catch(error){
      erroredRef.current=true
      forceUpdate()
    }
  }
  const unsubscribe = api.subscribe(listener)
  if(api.getState()!==stateBeforeSubscriptionRef.current){
    listener() // state has changed before subscription
  }
  return unsubscribe
},[])
```
这段代码要先从 api.subscribe(listener)看
，这是的任何setState都会触发listener的执行，而listener利用api.getState()拿到最新state，并拿到上一次的compare函数equalityFnRef执行一下判断值前后是否发生了改变，如果改变则更新currentSliceRef并进行一次强制刷新(调用forceUpdate)

## context的实现
注意到context语法，可以创建多个互不干扰的store实例：
```js
import create from 'zustand'
import createContext from 'zustand/context'

const { Provider, useStore：useContextStore } = createContext()
const createStore = create(s=>s)// ...
const App=()=>(
  <Provider createStore={createStore}>
  // ...
  </Provider>
)
```
1. create创建的store是互不干扰的
2. create返回的useStore只有一个实例
3. 没有Provider作用域

Provider储存了create返回的useStore
```ts
const storeRef=useRef<TUseBoundStore>()
storeRef.current=createStore()
```
那么useStore本身不实现数据流功能
而是将Provider提供的storeRef拿到并返回即可
```ts
const useStore:UseContextStore<TState>= <StateSlice>(
  selector?: StateSelector<TState,StateSlice>,
  equalityFn = Object.is
)=>{
  const useProviderStore=useContext(ZustandContext)
  return useProviderStore(
    selector as StateSelector<TState,StateSlice>,
    equalityFn
  )
}
```
核心逻辑还是是现在 create函数里
context.ts 只是利用ReactContext将useStore注入到组件，
且利用ReactContext的特性，
这个注入可以存在多个实例，且不会相互影响。

## 中间件
中间件其实不需要怎么实现。比如看这个 redux 中间件的例子：

```js
import { redux } from 'zustand/middleware'
const useStore = create(redux(reducer, initialState))
```

可以将 zustand 用法改变为 reducer，实际上是利用了函数式理念，redux 函数本身可以拿到 set, get, api，
如果想保持 API 不变，则原样返回 callback 就行了，
如果想改变用法，则返回特定的结构，就是这么简单。

为了加深理解，我们看看 redux 中间件源码：

```js
// 简化无TS类型版
export const redux = ( reducer, initial ) => ( set, get, api ) => {
  api.dispatch = action => {
    set(state => reducer(state, action), false, action)
    return action
  }
  api.dispatchFromDevtools = true
  return { dispatch: (...a) => api.dispatch(...a), ...initial }
}
```

```ts
// NamedSet: SetStateLike
const reduxImpl: ReduxImpl = (reducer, initial) => (set, _get, api) => {
  type S = typeof initial
  type A = Parameters<typeof reducer>[1]
  ;(api as any).dispatch = (action: A) => {
    ;(set as NamedSet<S>)((state: S) => reducer(state, action), false, action)
    return action
  }
  ;(api as any).dispatchFromDevtools = true

  return { dispatch: (...a) => (api as any).dispatch(...a), ...initial }
}
```

将 set, get, api 封装为 redux API：dispatch 本质就是调用 set。

# 总结
zustand 是一个实现精巧的 React 数据流管理工具，自身框架无关的分层合理，中间件实现巧妙，值得学习。
